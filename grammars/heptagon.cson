scopeName: "source.heptagon"
name: "Heptagon"
fileTypes: [
	"ept"
]
patterns: [
	{
		include: "#externFile"
	}
	{
		include: "#function"
	}
	{
		include: "#comment"
	}
	{
		include: "#constant"
	}
]
repository:
	constant:
		begin: "\\s*(const)\\s+(\\w+)\\s*:\\s*(\\w+)\\s*(=)\\s*(.*)"
		beginCaptures:
			1: name: "storage.type.heptagon"
			2: name: "variable.other.heptagon"
			3:
				patterns: [
					{
						include: "#type"
					}
				]
			4: name: "keyword.operator.heptagon"
			5: patterns: [
				{
					include: "#constantValue"
				}
			]
		end: "\\s*$"
	comment:
		begin: "\\(\\*"
		name: "comment.block.heptagon"
		end: "\\*\\)"
	externFile:
		match: "^\\s*(open)\\s*(\\w*)"
		captures:
			1: name: "storage.type.heptagon"
			2: name: "variable.other.heptagon"
	function:
		begin: "(fun|node)\\s+(\\w+)\\s*(?:<<([^>]*)>>)?\\s*\\(([\\w\\s:;]*)\\)\\s*(returns)\\s*\\(([\\w\\s:;]*)\\)"
		beginCaptures:
			1: name: "storage.type.heptagon"
			2: name: "entity.name.function.heptagon"
			3:
				patterns: [
					{
						include: "#staticArg"
					}
				]
			4:
				patterns: [
					{
						include: "#parameterList"
					}
				]
			5: name: "keyword.control.heptagon"
			6:
				patterns: [
					{
						include: "#parameterList"
					}
				]
		patterns: [
			{
				begin: "let"
				beginCaptures: 0: name: "keyword.control.heptagon"
				patterns: [
					{
						include: "#comment"
					}
					{
						begin: "\\s*(\\w+|\\(\\))\\s*(=)\\s*"
						beginCaptures:
							1: name: "variable.other.heptagon"
							2: name: "keyword.operator.heptagon"
						patterns: [
							{
								include: "#letConstruct"
							}
						]
						end: "\\s*;"
					}
				]
				end: "(?=tel)"
			}
			{
				begin: "var"
				beginCaptures: 0: name: "keyword.control.heptagon"
				patterns: [
					{
						match: "\\s*([\\s\\w,:]+);"
						captures:
							1:
								patterns: [
									{
										include: "#parameterDec"
									}
								]
					}
				]
				end: "(?=(let|tel))"
			}
		]
		end: "(tel)"
		endCaptures: 1: name: "keyword.control.heptagon"
	letConstruct:
		patterns: [
			{
				begin: "(merge)\\s+(\\w+)"
				beginCaptures:
					1: name: "keyword.control.heptagon"
					# 2: name: "variable.other.heptagon" # NOTE: to much colored with this
				patterns: [
					{
						match: "\\((\\w+)\\s*->(.*)\\)"
						captures:
							1:
								patterns: [
									{
										include: "#languageBoolean"
									}
								]
							2:
								patterns: [
									{
										include: "#assignment"
									}
								]
					}
				]
				end: "(?=;)"
			}
			{
				begin: "(if)\\s+(\\w+)\\s+(?=then)"
				beginCaptures:
					1: name: "keyword.control.heptagon"
					# 2: name: "variable.other.heptagon" # NOTE: to much colored with this
				patterns: [
					{
						match: "(then)\\s+(.*)\\s+(?=else)"
						captures:
							1: name: "keyword.control.heptagon"
							2:
								patterns: [
									{
										include: "#assignment"
									}
								]
					}
				]
				end: "(else)\\s+(.*)\\s*(?=;)"
				endCaptures:
					1: name: "keyword.control.heptagon"
					2:
						patterns: [
							{
								include: "#assignment"
							}
						]
			}
			{
				match: "(.*)(?=;)"
				captures:
					1:
						patterns: [
							{
								include: "#assignment"
							}
						]
				end: "(?=;)"
			}
		]
	assignment:
		patterns: [
			{
				comment: "Function call"
				match: "\\s*(\\w+)\\s*(?:(<<)(.*)(>>))?\\s*\\((.*)\\)\\s*"
				captures:
					1: name: "entity.name.function.heptagon"
					2: name: "entity.name.function.heptagon" # '<<' is considered as part of the function name
					# TODO: add coloration for the 3rd group
					4: name: "entity.name.function.heptagon" # '>>' is considered as part of the function name
					5:
						patterns: [
							{
								match: "([\\w\\s,]+)"
								captures:
									1:
										patterns: [
											{
												match: "([\\w\\s]+)"
												captures:
													1:
														patterns: [
															{
																include: "#assignment"
															}
														]
											}
										]
							}
							{
								match: "\\s*"
							}
						]
			}
			{
				comment: "Operator named"
				match: "\\s*(.*)\\s+(whenot|fby|when)\\s+(.*)\\s*"
				captures:
					1: patterns: [ { include: "#assignment" } ]
					2: name: "keyword.operator.heptagon"
					3: patterns: [ { include: "#assignment" } ]
			}
			{
				comment: "Operator"
				match: "\\s*(.*)\\s*(=|\\+|-|%|\\/|\\*|\\+.|-.|%.|\\/.|\\*.)\\s*(.*)\\s*"
				captures:
					1: patterns: [ { include: "#assignment" } ]
					2: name: "keyword.operator.heptagon"
					3: patterns: [ { include: "#assignment" } ]
			}
			{
				comment: "Parenthesis"
				match: "\\s*\\((.*)\\)\\s*"
				captures:
					1: patterns: [ { include: "#assignment" } ]
			}
			{
				include: "#languageConstant"
			}
			{
				include: "#constantValue"
			}
			# { # NOTE: to much colored with this
			# 	comment: "Other variable name"
			# 	match: "\\s*(\\w+)\\s*"
			# 	captures:
			# 		1: name: "variable.other.heptagon"
			# }
		]
	staticArg:
		patterns: [
			{
				match: "(\\w+)\\s*:\\s*(\\w+)(?:\\s*\\,\\s*(\\w+)\\s*:\\s*(\\w+))*"
				captures:
					1: name: "variable.parameter.heptagon"
					2:
						patterns: [
							{
								include: "#type"
							}
						]
					3: name: "variable.parameter.heptagon"
					4:
						patterns: [
							{
								include: "#type"
							}
						]
			}
		]
	parameterList:
		match: "\\s*(?:(\\w+)\\s*:\\s*(\\w+)(?:\\s*;\\s*(\\w+)\\s*:\\s*(\\w+))*)?\\s*"
		captures:
			1: name: "variable.parameter.heptagon"
			2:
				patterns: [
					{
						include: "#type"
					}
				]
			3: name: "variable.parameter.heptagon"
			4:
				patterns: [
					{
						include: "#type"
					}
				]
	parameterDec:
		match: "(?:([\\w\\s,]+)):\\s*(\\w+)\\s*"
		captures:
			1:
				patterns: [
					{
						match: "(\\w+)"
						captures: 1: name: "variable.other.heptagon"
					}
				]
			2:
				patterns: [
					{
						include: "#type"
					}
				]
	constantValue:
		patterns: [
			{
				match: "\\s*(0x\\h+)\\s*" # Hexadecimal
				captures: 1: name: "constant.numeric.heptagon"
			}
			{
				match: "\\s*(\\d+)\\s*" # Integers
				captures: 1: name: "constant.numeric.heptagon"
			}
		]
	type:
		match: "(int|bool)"
		name: "entity.name.type.heptagon"
	languageConstant:
		patterns: [
			{
				include: "#languageBoolean"
			}
		]
	languageBoolean:
		match: "(true|false)"
		captures: 1: name: "constant.language.heptagon"
